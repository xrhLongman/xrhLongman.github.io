<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>论十二分钟跑</title>
      <link href="/2022/09/21/%E8%AE%BA%E5%8D%81%E4%BA%8C%E5%88%86%E9%92%9F%E8%B7%91/"/>
      <url>/2022/09/21/%E8%AE%BA%E5%8D%81%E4%BA%8C%E5%88%86%E9%92%9F%E8%B7%91/</url>
      
        <content type="html"><![CDATA[<blockquote><p>浙大大一同学们在体育上的两问：<br>1.打卡打了吗？    2.十二分钟跑怎么跑？</p></blockquote><h2 id="成果概览"><a href="#成果概览" class="headerlink" title="成果概览"></a>成果概览</h2><p>话不多说，先上今日晚上数据，热乎的<br><img src="https://s2.loli.net/2022/09/21/m86O4er2FsSRbBf.jpg"></p><h2 id="优缺点分析"><a href="#优缺点分析" class="headerlink" title="优缺点分析"></a>优缺点分析</h2><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><p>1.光看成绩，的确比暑假里好吃懒做生活作风之下的成绩好了很多，这点不用多说<br>2.看心率区间，也是可圈可点(doge)，有点像“正态分布”(再次doge)。有氧耐力区明显增加，从数据上好像进步很大，但是我真正在跑的时候，并未感觉到明显的游刃有余，而是像之前一样疲惫；虽然前几天有充分的休息(摆烂)，但是小腿肌肉的酸痛感从200m处就开始了，而且成指数倍加剧，跑的时候看到成绩并未因此波动，还是挺诧异的。<br>3.训练效果还是有氧多，这点其实是相当疑惑的。跑的时候明明疲惫不堪，为什么心率还没有超过所谓阈值？高驰的数据记录相当准确，但是数据分析总是让我不敢恭维。</p><h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><p>1.一个已经很难改掉的毛病：无法匀速，会不定期地变速。有个不太厚道的理由是人比较多，但是拐弯之类的消耗的体力，并不会造成有规律的变速，再说如此细微的波动，高驰也未必看得出来。平均每2分钟会变一次速，总感觉一减速再一加速有利于调整心态，但是利于体力的维持。<br>2.这样的夜跑主要目的是让我的十二分钟跑达标，这种成绩大概一周能跑出一两次已经很不错了，每次跑完之后第二天下床了就站不稳，蹬个自行车都难受。这就是我们“爱好者”最难以改变的一点：不可持续性。普通的5分配，一周跑量有三四十公里（我），有的大佬必然更多；然而真正能达到浙大十二分钟跑两千八标准的，恐怕一周也没几次，这点上只能慢慢加强呗。</p><h2 id="还没完呢"><a href="#还没完呢" class="headerlink" title="还没完呢"></a>还没完呢</h2><p>我再多bb两句，<a href="https://www.163.com/dy/article/HHS5031P0553TQCA.html">2022年柏林马拉松</a>将于大后天(25日)鸣枪开跑，双冠王基普乔格和卫冕冠军阿多拉同台竞技，中国选手仁青东知布、何杰参赛，必将相当精彩。当然，在我看来，冠军应该会还是那个男人，毕竟之前都已经鸽了多少场大赛了，悬念已经拉满了，可别让我失望捏。<br><img src="https://s2.loli.net/2022/09/22/BI6QM98NfjxRFiv.jpg"></p>]]></content>
      
      
      <categories>
          
          <category> 大学生活 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 长跑 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>暑假跑步锻炼感想</title>
      <link href="/2022/07/21/%E6%9A%91%E5%81%87%E8%B7%91%E6%AD%A5%E9%94%BB%E7%82%BC%E6%84%9F%E6%83%B3/"/>
      <url>/2022/07/21/%E6%9A%91%E5%81%87%E8%B7%91%E6%AD%A5%E9%94%BB%E7%82%BC%E6%84%9F%E6%83%B3/</url>
      
        <content type="html"><![CDATA[<h2 id="之前的情况"><a href="#之前的情况" class="headerlink" title="之前的情况"></a>之前的情况</h2><p>初中我1000mPB3分15秒，高中曾突破3分10秒，这个和所谓的“严肃跑者”还是由天壤之别，但是放在一群只会在座位上卷得天昏地暗的同龄人，我在这个方面还是有一点突出的。高中阶段因为体育课没有专门开设的田径课，我主修篮球，因此在上学时间是没有办法进行长时间练耐力的。但我们有“夜跑”的传统，我也算是夜跑大队中的积极分子。每天去操场上挥汗如雨，没什么时间的话会进行3~4组1200m的“放松跑”，稍微有点时间则会跑个5k，如果时间相当充裕就可以来个多一点的800m间歇跑，虽然有的时候会眼高手低，但总的来说整个人还在状态。但是因为高考备考时晚上苦苦内卷，暂缓夜跑计划，整个人直接就增重十斤，啤酒肚都挺了出来，再也不能从容地拉LSD，甚至跑个20min的5K都吁吁带喘。</p><h2 id="近期的小结"><a href="#近期的小结" class="headerlink" title="近期的小结"></a>近期的小结</h2><p>虽然一个暑假好像回转不到之前的状态，但我还是给自己配备了冠军同款装备：<a href="https://cn.coros.com/pace2">COROS PACE 2</a>和<a href="https://www.nike.com/running/alphafly">Nike ZoomX Alphafly Next%</a>，另配备用于五分配有氧间歇的<a href="https://www.nikestore.com.cn/t/Nike%20ZoomX%20Invincible%20Run%20FK%202/DH5425?spuCode=DH5425-102">Nike ZoomX Invincible</a>，一举蜕变为装备党。<br>因为网友反应破二的ZoomX中底磨成外低，极不耐磨，我现在一般全部用Invincible拉速度。破二是1400左右入的，入之前也综合考虑了网友们口中“一公里10元”“驾驭门槛很高”之类的，但我毕竟是乔爷的粉丝，又觉得这双鞋的确很有纪念意义，这其中的情怀只可意会，放在家里供着都赏心悦目，因此剁手入了Tokyo配色。至于这双Invincible，没有板材加持，中底就是那种标准的感觉，鞋楦和外底都令人满意，有兴趣的朋友可以看<a href="https://www.bilibili.com/video/BV1J34y1d7yx?spm_id_from=333.337.search-card.all.click&vd_source=5426ebcce42b6260be3b4058fefeb5da">宁哥的测评</a>，说实话用来作健步鞋还是挺不错的，但4到5分配的也能稳定地释放性能。在装备初到，也就是三一招生结束时，我进行了一次间歇跑练习，其中选取出成绩还过的去的一次，先放在下面。（有点长，但是懂的都懂，手机和电脑翻阅应该问题不大）<br><img src="https://s2.loli.net/2022/07/21/J8hBcjTzCqp4DQX.jpg"></p><h2 id="阈值下滑"><a href="#阈值下滑" class="headerlink" title="阈值下滑"></a>阈值下滑</h2><p>我的路线没法和场地跑比，甚至和路跑还差得远，有十段左右的上下坡和长台阶，因此节奏较难调整（这个从图中也能看到），但这不是我成绩不理想的原因。即使刨去这些，我的成绩还是不堪入目，这只是间歇跑中的一段，且跑前有较为充足的休息，配速依旧难看。主要从心率分析：有氧的和无氧的占绝大多数，几乎没有在无氧耐力附近的，高驰app给出的评价是：运动效果不明显，又伤身体。出现这种情况的主要原因是：因为有半年没跑步，乳酸阈值有所下滑，除了几个减速后的起步是有氧之外，其他都是无氧，跑得相当痛苦，有违有氧训练的初衷，但是起步也只好如此。</p><h2 id="如何回转"><a href="#如何回转" class="headerlink" title="如何回转"></a>如何回转</h2><p>这是我回复半月以后的数据。<br><img src="https://s2.loli.net/2022/07/21/EpbO9LtgXvkdQHh.jpg"><br>浙江大学的体艺科保留项目是十二分钟跑，这个项目我在高中可以较轻松跑到3k，但是如今就不行了。上面这个是我为了准备而记录的稍微有代表性的一个数据。节奏比较合理，虽然还是走了分段加速的老路，但是总体而言并未跑得很疲惫，可能是乳酸阈值训练的效果。有氧占了大多数，无氧也在合理范围内。这次的跑道有接近90度的转弯，单圈约是300m，其实对加速有影响，这个实属疫情影响所限，附近的体育馆大多都不开放。但数据表明，运动状态有所回升，这个令人振奋。</p><h2 id="恢复策略"><a href="#恢复策略" class="headerlink" title="恢复策略"></a>恢复策略</h2><p>每天拉练5K左右，先拉2K的配速跑，再进行400m的间歇，亲测是比较适合于长期运动量较小又很想提升状态的跑友们。</p>]]></content>
      
      
      <categories>
          
          <category> 大学生活 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 长跑 </tag>
            
            <tag> 训练 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C语言写贪吃蛇</title>
      <link href="/2022/07/21/C%E8%AF%AD%E8%A8%80%E5%86%99%E8%B4%AA%E5%90%83%E8%9B%87/"/>
      <url>/2022/07/21/C%E8%AF%AD%E8%A8%80%E5%86%99%E8%B4%AA%E5%90%83%E8%9B%87/</url>
      
        <content type="html"><![CDATA[<blockquote><p>用C语言写贪吃蛇就是为难它去作前端的典范，但也是我们不得不越过的一个坎</p></blockquote><h2 id="先上代码"><a href="#先上代码" class="headerlink" title="先上代码"></a>先上代码</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;windows.h&gt;</span><br><span class="line">#include &lt;time.h&gt;</span><br><span class="line">#define MAXLEN 60//最长的蛇长 </span><br><span class="line">char bg[20][48] = &#123;</span><br><span class="line">                                &quot;■■■■■■■■■■■■■■■■■■■■■■■\n&quot;,</span><br><span class="line">                                &quot;■                                          ■\n&quot;,</span><br><span class="line">                                &quot;■                                          ■\n&quot;,</span><br><span class="line">                                &quot;■                                          ■\n&quot;,</span><br><span class="line">                                &quot;■                                          ■\n&quot;,</span><br><span class="line">                                &quot;■                                          ■\n&quot;,</span><br><span class="line">                                &quot;■                                          ■\n&quot;,</span><br><span class="line">                                &quot;■                                          ■\n&quot;,</span><br><span class="line">                                &quot;■                                          ■\n&quot;,</span><br><span class="line">                                &quot;■                                          ■\n&quot;,</span><br><span class="line">                                &quot;■                                          ■\n&quot;,</span><br><span class="line">                                &quot;■                                          ■\n&quot;,</span><br><span class="line">                                &quot;■                                          ■\n&quot;,</span><br><span class="line">                                &quot;■                                          ■\n&quot;,</span><br><span class="line">                                &quot;■                                          ■\n&quot;,</span><br><span class="line">                                &quot;■                                          ■\n&quot;,</span><br><span class="line">                                &quot;■                                          ■\n&quot;,</span><br><span class="line">                                &quot;■                                          ■\n&quot;,</span><br><span class="line">                                &quot;■                                          ■\n&quot;,</span><br><span class="line">                                &quot;■■■■■■■■■■■■■■■■■■■■■■■\n&quot;</span><br><span class="line">                                                            &#125;;</span><br><span class="line">enum &#123;r = 2, l = -2, u = -1, d = 1&#125;;//联合方向</span><br><span class="line">//蛇数组</span><br><span class="line">int sn[MAXLEN][3] = &#123;0&#125;;  //[i][0]行，[i][1]列，[i][2]移动的方向</span><br><span class="line">//蛇的方向</span><br><span class="line">int sndir = l;</span><br><span class="line">int profood = 1;</span><br><span class="line">int g_Row, g_Col;//用于记录随机的坐标 </span><br><span class="line">int snlen = 2; //初始长度 </span><br><span class="line">int sc = 0;//初始分数 </span><br><span class="line">//int *sp;//初始刷新率(速度) </span><br><span class="line">//int gap;</span><br><span class="line">int gap=200;</span><br><span class="line"></span><br><span class="line">void page() &#123;</span><br><span class="line">printf(&quot;贪吃蛇简陋终端版(xrhLongman倾情提供)\n&quot;);</span><br><span class="line">printf(&quot;游戏规则\n&quot;);</span><br><span class="line">printf(&quot;1.按w(上)s(下)a(左)d(右)来控制蛇的运动\n&quot;);</span><br><span class="line">printf(&quot;2.□代表蛇头，■代表蛇身，●代表食物\n&quot;);</span><br><span class="line">printf(&quot;3.蛇每吃一个食物身体会变长一个单位\n&quot;);</span><br><span class="line">printf(&quot;4.若蛇碰到围栏或碰到自己则游戏结束\n&quot;);</span><br><span class="line">    printf(&quot;回车即开始游戏:&quot;);</span><br><span class="line">&#125;</span><br><span class="line">void ifspace() &#123;</span><br><span class="line">    char ch;</span><br><span class="line">    while (ch = getchar()) &#123;</span><br><span class="line">        if(ch=&#x27;h&#x27;)&#123;</span><br><span class="line">      gap=50;</span><br><span class="line">&#125;else if (ch == &#x27;j&#x27;) &#123;</span><br><span class="line">      gap=100;</span><br><span class="line">&#125;else if(ch==&#x27;k&#x27;)&#123;</span><br><span class="line">gap=150;</span><br><span class="line">&#125;else if(ch==&#x27;l&#x27;)&#123;</span><br><span class="line">gap=200;</span><br><span class="line">&#125;</span><br><span class="line">break;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">void printbg() &#123;</span><br><span class="line">int i; </span><br><span class="line">    for (i = 0; i &lt; 20; i++) &#123;</span><br><span class="line">        printf(bg[i]);    //以行为单位打印背景 </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">void printsn() &#123;</span><br><span class="line">int i;</span><br><span class="line">    strncpy(&amp;bg[sn[0][0]][sn[0][1]], &quot;□&quot;, 2);</span><br><span class="line">    for (i = 1; sn[i][0] != 0; i++) &#123;   //连续循环3次打印出初始的蛇 </span><br><span class="line">        strncpy(&amp;bg[sn[i][0]][sn[i][1]], &quot;■&quot;, 2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">//删除蛇残留</span><br><span class="line">void DestroySnake() &#123;</span><br><span class="line">int i;</span><br><span class="line">    for (i = 0; sn[i][0] != 0; i++) &#123;   //连续循环3次，把方块拷贝到空白地图上面</span><br><span class="line">        strncpy(&amp;bg[sn[i][0]][sn[i][1]], &quot;  &quot;, 2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">//设置蛇的开始位置</span><br><span class="line">void randpos() &#123;</span><br><span class="line">    int nX = -1, nY = -1;</span><br><span class="line">    srand((unsigned int)time(NULL));   //设置随机数</span><br><span class="line">    nX = rand() % 19 + 1;    //第一个蛇方块上限是19</span><br><span class="line">    nY = rand() % 18 + 1;   //纵坐标上限是18 </span><br><span class="line">    sn[0][0] = nY;</span><br><span class="line">    sn[0][1] = nX * 2;</span><br><span class="line">    sn[0][2] = l;</span><br><span class="line"></span><br><span class="line">    sn[1][0] = nY;</span><br><span class="line">    sn[1][1] = nX * 2 + 2;</span><br><span class="line">    sn[1][2] = l;</span><br><span class="line"></span><br><span class="line">    sn[2][0] = nY; </span><br><span class="line">    sn[2][1] = nX * 2 + 4;</span><br><span class="line">    sn[2][2] = l;</span><br><span class="line">    printsn();</span><br><span class="line">&#125;</span><br><span class="line">void move() &#123;</span><br><span class="line">    //删掉原来的蛇</span><br><span class="line">    DestroySnake();</span><br><span class="line"></span><br><span class="line">    int i = MAXLEN - 1; </span><br><span class="line">    int j;</span><br><span class="line">    for (i; i &gt;= 1; i--) &#123;</span><br><span class="line">        if (sn[i][1] == 0) continue;</span><br><span class="line">        //把前一段身体数据拷贝给后一段 </span><br><span class="line">        sn[i][0] = sn[i - 1][0];</span><br><span class="line">        sn[i][1] = sn[i - 1][1];</span><br><span class="line">        sn[i][2] = sn[i - 1][2];</span><br><span class="line">    &#125;</span><br><span class="line">    //处理蛇头</span><br><span class="line">    sn[0][2] = sndir;  //初始化方向为向西</span><br><span class="line">    //如果是东西方向</span><br><span class="line">    if (sn[0][2] == l || sn[0][2] == r) &#123;</span><br><span class="line">        sn[0][1] += sn[0][2];</span><br><span class="line">    &#125; else &#123;  //如果是东西方向</span><br><span class="line">        sn[0][0] += sn[0][2];</span><br><span class="line">    &#125;</span><br><span class="line">    for (j = MAXLEN - 1; j &gt;= 1; j--) &#123;</span><br><span class="line">        if (sn[j][1] == 0) continue;</span><br><span class="line">        //sn[0][0]和sn[0][1]为蛇头坐标</span><br><span class="line">        //判断蛇头改变方向以后会不会咬到自己</span><br><span class="line">        if (sn[0][0] == sn[j][0] &amp;&amp; sn[0][1] == sn[j][1]) &#123;</span><br><span class="line">                printf(&quot;游戏结束!\n&quot;);</span><br><span class="line">                printf(&quot;最终分数: %d\n&quot;, sc);</span><br><span class="line">                system(&quot;pause&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line">//蛇随方向动起来</span><br><span class="line">void change() &#123;</span><br><span class="line">    //GetAsyncKeystate()异步检测函数</span><br><span class="line">    //GetAsyncKeyState(&#x27;W&#x27;); //如果输入W，就返回一个非0值</span><br><span class="line">    if (GetAsyncKeyState(&#x27;W&#x27;)) &#123;</span><br><span class="line">        if (sn[0][2] != d) &#123;  //不能向相反的方向走</span><br><span class="line">            sndir = u;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; else if (GetAsyncKeyState(&#x27;S&#x27;)) &#123;</span><br><span class="line">        if (sn[0][2] != u) &#123;</span><br><span class="line">            sndir = d;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; else if (GetAsyncKeyState(&#x27;A&#x27;)) &#123;</span><br><span class="line">        if (sn[0][2] != r) &#123;</span><br><span class="line">            sndir = l;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; else if (GetAsyncKeyState(&#x27;D&#x27;)) &#123;</span><br><span class="line">        if (sn[0][2] != l) &#123;</span><br><span class="line">            sndir = r;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">//是否死亡</span><br><span class="line">int over() &#123;</span><br><span class="line">        if (!strncmp(&amp;bg[sn[0][0]][sn[0][1]], &quot;■&quot;, 2)) &#123;</span><br><span class="line">            return 0;</span><br><span class="line">    &#125;</span><br><span class="line">    return 1;</span><br><span class="line">&#125;</span><br><span class="line">//产生食物</span><br><span class="line">void produce() &#123;</span><br><span class="line">int i;</span><br><span class="line">if (profood == 0)//判断是否产生新的食物</span><br><span class="line">        return;</span><br><span class="line">    int flag = 1;</span><br><span class="line">    srand((unsigned int)time(NULL));</span><br><span class="line">    while (1) &#123;</span><br><span class="line">        g_Row = rand() % 18 + 1;</span><br><span class="line">        g_Col = rand() % 20 + 1;</span><br><span class="line">        //若产生在蛇身，重新生成</span><br><span class="line">        for (i = 0; sn[i][0] != 0; i++)</span><br><span class="line">            if (sn[i][0] == g_Row &amp;&amp; sn[i][1] == g_Col)</span><br><span class="line">                flag = 0;</span><br><span class="line">        if (flag == 1)</span><br><span class="line">            break;</span><br><span class="line">    &#125;</span><br><span class="line">    strncpy(&amp;bg[g_Row][g_Col * 2], &quot;●&quot;, 2);</span><br><span class="line">    profood = 0;</span><br><span class="line">&#125;</span><br><span class="line">//蛇长</span><br><span class="line">void grow() &#123;</span><br><span class="line">    //食物坐标和蛇头坐标相等</span><br><span class="line">    if (sn[0][0] == g_Row &amp;&amp; sn[0][1] == g_Col * 2) &#123;</span><br><span class="line">        if (sn[0][2] == r) &#123;  //判断尾部在哪个方向</span><br><span class="line">            sn[snlen + 1][0] = sn[snlen][0];</span><br><span class="line">            sn[snlen + 1][1] = sn[snlen][1] - 2;</span><br><span class="line">            sn[snlen + 1][2] = sn[snlen][2];</span><br><span class="line">        &#125; else if (sn[0][2] == l) &#123;</span><br><span class="line">            sn[snlen + 1][0] = sn[snlen][0];</span><br><span class="line">            sn[snlen + 1][1] = sn[snlen][1] + 2;</span><br><span class="line">            sn[snlen + 1][2] = sn[snlen][2];</span><br><span class="line">        &#125; else if (sn[0][2] == u) &#123;</span><br><span class="line">            sn[snlen + 1][0] = sn[snlen][0] + 1;</span><br><span class="line">            sn[snlen + 1][1] = sn[snlen][1];</span><br><span class="line">            sn[snlen + 1][2] = sn[snlen][2];</span><br><span class="line">        &#125; else if (sn[0][2] == d)&#123;</span><br><span class="line">            sn[snlen + 1][0] = sn[snlen][0] - 1;</span><br><span class="line">            sn[snlen + 1][1] = sn[snlen][1];</span><br><span class="line">            sn[snlen + 1][2] = sn[snlen][2];</span><br><span class="line">        &#125;</span><br><span class="line">        snlen++;</span><br><span class="line">        profood = 1;</span><br><span class="line">        sc++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">void Score() &#123;</span><br><span class="line">    COORD rd;</span><br><span class="line">    rd.X = 56;</span><br><span class="line">    rd.Y = 8;</span><br><span class="line">    //设置光标位置</span><br><span class="line">    SetConsoleCursorPosition(GetStdHandle(STD_OUTPUT_HANDLE), rd);</span><br><span class="line">    printf(&quot;分数: &quot;);</span><br><span class="line">rd.X = 64;</span><br><span class="line">    rd.Y = 8;</span><br><span class="line">    //设置光标位置</span><br><span class="line">    SetConsoleCursorPosition(GetStdHandle(STD_OUTPUT_HANDLE), rd);</span><br><span class="line">    //打印</span><br><span class="line">    printf(&quot;%d&quot;, sc);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    page();//首页</span><br><span class="line">    ifspace();//回车开始 </span><br><span class="line">    system(&quot;cls&quot;);</span><br><span class="line">    randpos();//初始化蛇的位置 </span><br><span class="line">    //打印界面</span><br><span class="line">    while (1) &#123;</span><br><span class="line">        system(&quot;cls&quot;); </span><br><span class="line">        change();//改变方向</span><br><span class="line">        grow();//蛇变长</span><br><span class="line">     produce();//产生食物</span><br><span class="line">        move();</span><br><span class="line">        //判断蛇是否死亡</span><br><span class="line">        if (over() == 0) &#123;</span><br><span class="line">            printf(&quot;游戏结束！\n&quot;);</span><br><span class="line">            printf(&quot;最终分数: %d\n&quot;, sc);</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">        printsn();//在背景上显示蛇</span><br><span class="line">    printbg(); //打印背景</span><br><span class="line">       Score(); //打印分数</span><br><span class="line">        //Sleep(*sp); </span><br><span class="line">Sleep(150); //速度好像不可调 (这个是我小丑了,求教大佬) </span><br><span class="line">    &#125;</span><br><span class="line">    system(&quot;pause&quot;);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="问题汇总"><a href="#问题汇总" class="headerlink" title="问题汇总"></a>问题汇总</h2><p>从开始写这个程序，到最后排除可解决的问题，整整用了我一天的时间；虽然写了这么久，还是有很多问题，给大家列一下<br>1.最大的问题，经常卡顿甚至奔溃，而且发生此类事故时分数没有任何规律<br>2.在蛇头碰到自己身体时，连续胡乱变动方向，可以继续游戏<br>3.现在还不知道如何实现在开始游戏后改变蛇运动速度<br>4.不管如何调整速度，均会出现不均匀的屏闪现象，有害视力<br>5.很多部分我都设置为默认数据，并未给玩家留足够的发挥空间</p><h2 id="总纲分解"><a href="#总纲分解" class="headerlink" title="总纲分解"></a>总纲分解</h2><p>主要分为界面交互系统、蛇系统、奖励与惩罚系统、分数系统</p><h3 id="界面交互系统"><a href="#界面交互系统" class="headerlink" title="界面交互系统"></a>界面交互系统</h3><p>首先要打印出规则界面，要玩家输入指令来触发游戏<br>每次都需要打印出围栏，这里先用固定的二维数组实现<br>别的都不用赘述，只是其中的一个ifspace()函数中想要实现初始的调速控制，但最后没有成功</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line">char bg[20][48] = &#123;</span><br><span class="line">                                &quot;■■■■■■■■■■■■■■■■■■■■■■■\n&quot;,</span><br><span class="line">                                &quot;■                                          ■\n&quot;,</span><br><span class="line">                                &quot;■                                          ■\n&quot;,</span><br><span class="line">                                &quot;■                                          ■\n&quot;,</span><br><span class="line">                                &quot;■                                          ■\n&quot;,</span><br><span class="line">                                &quot;■                                          ■\n&quot;,</span><br><span class="line">                                &quot;■                                          ■\n&quot;,</span><br><span class="line">                                &quot;■                                          ■\n&quot;,</span><br><span class="line">                                &quot;■                                          ■\n&quot;,</span><br><span class="line">                                &quot;■                                          ■\n&quot;,</span><br><span class="line">                                &quot;■                                          ■\n&quot;,</span><br><span class="line">                                &quot;■                                          ■\n&quot;,</span><br><span class="line">                                &quot;■                                          ■\n&quot;,</span><br><span class="line">                                &quot;■                                          ■\n&quot;,</span><br><span class="line">                                &quot;■                                          ■\n&quot;,</span><br><span class="line">                                &quot;■                                          ■\n&quot;,</span><br><span class="line">                                &quot;■                                          ■\n&quot;,</span><br><span class="line">                                &quot;■                                          ■\n&quot;,</span><br><span class="line">                                &quot;■                                          ■\n&quot;,</span><br><span class="line">                                &quot;■■■■■■■■■■■■■■■■■■■■■■■\n&quot;</span><br><span class="line">                                                            &#125;;</span><br><span class="line">enum &#123;r = 2, l = -2, u = -1, d = 1&#125;;//联合方向</span><br><span class="line">//蛇数组</span><br><span class="line">int sn[MAXLEN][3] = &#123;0&#125;;  //[i][0]行，[i][1]列，[i][2]移动的方向</span><br><span class="line">//蛇的方向</span><br><span class="line">int sndir = l;</span><br><span class="line">int profood = 1;</span><br><span class="line">int g_Row, g_Col;//用于记录随机的坐标 </span><br><span class="line">int snlen = 2; //初始长度 </span><br><span class="line">int sc = 0;//初始分数 </span><br><span class="line">//int *sp;//初始刷新率(速度) </span><br><span class="line">//int gap;</span><br><span class="line">int gap=200;</span><br><span class="line"></span><br><span class="line">void page() &#123;</span><br><span class="line">printf(&quot;贪吃蛇简陋终端版(xrhLongman倾情提供)\n&quot;);</span><br><span class="line">printf(&quot;游戏规则\n&quot;);</span><br><span class="line">printf(&quot;1.按w(上)s(下)a(左)d(右)来控制蛇的运动\n&quot;);</span><br><span class="line">printf(&quot;2.□代表蛇头，■代表蛇身，●代表食物\n&quot;);</span><br><span class="line">printf(&quot;3.蛇每吃一个食物身体会变长一个单位\n&quot;);</span><br><span class="line">printf(&quot;4.若蛇碰到围栏或碰到自己则游戏结束\n&quot;);</span><br><span class="line">    printf(&quot;回车即开始游戏:&quot;);</span><br><span class="line">&#125;</span><br><span class="line">void ifspace() &#123;</span><br><span class="line">    char ch;</span><br><span class="line">    while (ch = getchar()) &#123;</span><br><span class="line">        if(ch=&#x27;h&#x27;)&#123;</span><br><span class="line">      gap=50;</span><br><span class="line">&#125;else if (ch == &#x27;j&#x27;) &#123;</span><br><span class="line">      gap=100;</span><br><span class="line">&#125;else if(ch==&#x27;k&#x27;)&#123;</span><br><span class="line">gap=150;</span><br><span class="line">&#125;else if(ch==&#x27;l&#x27;)&#123;</span><br><span class="line">gap=200;</span><br><span class="line">&#125;</span><br><span class="line">break;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">void printbg() &#123;</span><br><span class="line">int i; </span><br><span class="line">    for (i = 0; i &lt; 20; i++) &#123;</span><br><span class="line">        printf(bg[i]);    //以行为单位打印背景 </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="蛇系统"><a href="#蛇系统" class="headerlink" title="蛇系统"></a>蛇系统</h3><p>这一块较为复杂，利用率类似链表的思想。每次进行画面更新，先要删除原来的蛇，再检测键盘数据，再画上新的蛇<br>需要注意的是，在这一段程序中要判断蛇会不会咬到自己，这个命令的位置可以和是否撞墙的合并，我此处采用分离的模式<br>在检测键盘数据时，切勿用_getch()或者getchar()函数，这类函数使蛇在玩家未输入指令时停止，而GetAsyncKeystate()异步检测函数能时时测定并返回值</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><span class="line">void printsn() &#123;</span><br><span class="line">int i;</span><br><span class="line">    strncpy(&amp;bg[sn[0][0]][sn[0][1]], &quot;□&quot;, 2);</span><br><span class="line">    for (i = 1; sn[i][0] != 0; i++) &#123;   //连续循环3次打印出初始的蛇 </span><br><span class="line">        strncpy(&amp;bg[sn[i][0]][sn[i][1]], &quot;■&quot;, 2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">//删除蛇残留</span><br><span class="line">void DestroySnake() &#123;</span><br><span class="line">int i;</span><br><span class="line">    for (i = 0; sn[i][0] != 0; i++) &#123;   //连续循环3次，把方块拷贝到空白地图上面</span><br><span class="line">        strncpy(&amp;bg[sn[i][0]][sn[i][1]], &quot;  &quot;, 2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">//设置蛇的开始位置</span><br><span class="line">void randpos() &#123;</span><br><span class="line">    int nX = -1, nY = -1;</span><br><span class="line">    srand((unsigned int)time(NULL));   //设置随机数</span><br><span class="line">    nX = rand() % 19 + 1;    //第一个蛇方块上限是19</span><br><span class="line">    nY = rand() % 18 + 1;   //纵坐标上限是18 </span><br><span class="line">    sn[0][0] = nY;</span><br><span class="line">    sn[0][1] = nX * 2;</span><br><span class="line">    sn[0][2] = l;</span><br><span class="line"></span><br><span class="line">    sn[1][0] = nY;</span><br><span class="line">    sn[1][1] = nX * 2 + 2;</span><br><span class="line">    sn[1][2] = l;</span><br><span class="line"></span><br><span class="line">    sn[2][0] = nY; </span><br><span class="line">    sn[2][1] = nX * 2 + 4;</span><br><span class="line">    sn[2][2] = l;</span><br><span class="line">    printsn();</span><br><span class="line">&#125;</span><br><span class="line">void move() &#123;</span><br><span class="line">    //删掉原来的蛇</span><br><span class="line">    DestroySnake();</span><br><span class="line"></span><br><span class="line">    int i = MAXLEN - 1; </span><br><span class="line">    int j;</span><br><span class="line">    for (i; i &gt;= 1; i--) &#123;</span><br><span class="line">        if (sn[i][1] == 0) continue;</span><br><span class="line">        //把前一段身体数据拷贝给后一段 </span><br><span class="line">        sn[i][0] = sn[i - 1][0];</span><br><span class="line">        sn[i][1] = sn[i - 1][1];</span><br><span class="line">        sn[i][2] = sn[i - 1][2];</span><br><span class="line">    &#125;</span><br><span class="line">    //处理蛇头</span><br><span class="line">    sn[0][2] = sndir;  //初始化方向为向西</span><br><span class="line">    //如果是东西方向</span><br><span class="line">    if (sn[0][2] == l || sn[0][2] == r) &#123;</span><br><span class="line">        sn[0][1] += sn[0][2];</span><br><span class="line">    &#125; else &#123;  //如果是东西方向</span><br><span class="line">        sn[0][0] += sn[0][2];</span><br><span class="line">    &#125;</span><br><span class="line">    for (j = MAXLEN - 1; j &gt;= 1; j--) &#123;</span><br><span class="line">        if (sn[j][1] == 0) continue;</span><br><span class="line">        //sn[0][0]和sn[0][1]为蛇头坐标</span><br><span class="line">        //判断蛇头改变方向以后会不会咬到自己</span><br><span class="line">        if (sn[0][0] == sn[j][0] &amp;&amp; sn[0][1] == sn[j][1]) &#123;</span><br><span class="line">                printf(&quot;游戏结束!\n&quot;);</span><br><span class="line">                printf(&quot;最终分数: %d\n&quot;, sc);</span><br><span class="line">                system(&quot;pause&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line">//蛇随方向动起来</span><br><span class="line">void change() &#123;</span><br><span class="line">    //GetAsyncKeystate()异步检测函数</span><br><span class="line">    //GetAsyncKeyState(&#x27;W&#x27;); //如果输入W，就返回一个非0值</span><br><span class="line">    if (GetAsyncKeyState(&#x27;W&#x27;)) &#123;</span><br><span class="line">        if (sn[0][2] != d) &#123;  //不能向相反的方向走</span><br><span class="line">            sndir = u;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; else if (GetAsyncKeyState(&#x27;S&#x27;)) &#123;</span><br><span class="line">        if (sn[0][2] != u) &#123;</span><br><span class="line">            sndir = d;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; else if (GetAsyncKeyState(&#x27;A&#x27;)) &#123;</span><br><span class="line">        if (sn[0][2] != r) &#123;</span><br><span class="line">            sndir = l;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; else if (GetAsyncKeyState(&#x27;D&#x27;)) &#123;</span><br><span class="line">        if (sn[0][2] != l) &#123;</span><br><span class="line">            sndir = r;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">//是否死亡</span><br><span class="line">int over() &#123;</span><br><span class="line">        if (!strncmp(&amp;bg[sn[0][0]][sn[0][1]], &quot;■&quot;, 2)) &#123;</span><br><span class="line">            return 0;</span><br><span class="line">    &#125;</span><br><span class="line">    return 1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="奖励与惩罚系统"><a href="#奖励与惩罚系统" class="headerlink" title="奖励与惩罚系统"></a>奖励与惩罚系统</h3><p>这个系统涉及到贪吃蛇的核心部分：将蛇变长的判断依据为食物坐标和蛇头坐标相等<br>在显示分数时，为了避免麻烦而用来窗体自带的坐标函数来控制</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line">//产生食物</span><br><span class="line">void produce() &#123;</span><br><span class="line">int i;</span><br><span class="line">if (profood == 0)//判断是否产生新的食物</span><br><span class="line">        return;</span><br><span class="line">    int flag = 1;</span><br><span class="line">    srand((unsigned int)time(NULL));</span><br><span class="line">    while (1) &#123;</span><br><span class="line">        g_Row = rand() % 18 + 1;</span><br><span class="line">        g_Col = rand() % 20 + 1;</span><br><span class="line">        //若产生在蛇身，重新生成</span><br><span class="line">        for (i = 0; sn[i][0] != 0; i++)</span><br><span class="line">            if (sn[i][0] == g_Row &amp;&amp; sn[i][1] == g_Col)</span><br><span class="line">                flag = 0;</span><br><span class="line">        if (flag == 1)</span><br><span class="line">            break;</span><br><span class="line">    &#125;</span><br><span class="line">    strncpy(&amp;bg[g_Row][g_Col * 2], &quot;●&quot;, 2);</span><br><span class="line">    profood = 0;</span><br><span class="line">&#125;</span><br><span class="line">//蛇长</span><br><span class="line">void grow() &#123;</span><br><span class="line">    //食物坐标和蛇头坐标相等</span><br><span class="line">    if (sn[0][0] == g_Row &amp;&amp; sn[0][1] == g_Col * 2) &#123;</span><br><span class="line">        if (sn[0][2] == r) &#123;  //判断尾部在哪个方向</span><br><span class="line">            sn[snlen + 1][0] = sn[snlen][0];</span><br><span class="line">            sn[snlen + 1][1] = sn[snlen][1] - 2;</span><br><span class="line">            sn[snlen + 1][2] = sn[snlen][2];</span><br><span class="line">        &#125; else if (sn[0][2] == l) &#123;</span><br><span class="line">            sn[snlen + 1][0] = sn[snlen][0];</span><br><span class="line">            sn[snlen + 1][1] = sn[snlen][1] + 2;</span><br><span class="line">            sn[snlen + 1][2] = sn[snlen][2];</span><br><span class="line">        &#125; else if (sn[0][2] == u) &#123;</span><br><span class="line">            sn[snlen + 1][0] = sn[snlen][0] + 1;</span><br><span class="line">            sn[snlen + 1][1] = sn[snlen][1];</span><br><span class="line">            sn[snlen + 1][2] = sn[snlen][2];</span><br><span class="line">        &#125; else if (sn[0][2] == d)&#123;</span><br><span class="line">            sn[snlen + 1][0] = sn[snlen][0] - 1;</span><br><span class="line">            sn[snlen + 1][1] = sn[snlen][1];</span><br><span class="line">            sn[snlen + 1][2] = sn[snlen][2];</span><br><span class="line">        &#125;</span><br><span class="line">        snlen++;</span><br><span class="line">        profood = 1;</span><br><span class="line">        sc++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">void Score() &#123;</span><br><span class="line">    COORD rd;</span><br><span class="line">    rd.X = 56;</span><br><span class="line">    rd.Y = 8;</span><br><span class="line">    //设置光标位置</span><br><span class="line">    SetConsoleCursorPosition(GetStdHandle(STD_OUTPUT_HANDLE), rd);</span><br><span class="line">    printf(&quot;分数: &quot;);</span><br><span class="line">rd.X = 64;</span><br><span class="line">    rd.Y = 8;</span><br><span class="line">    //设置光标位置</span><br><span class="line">    SetConsoleCursorPosition(GetStdHandle(STD_OUTPUT_HANDLE), rd);</span><br><span class="line">    //打印</span><br><span class="line">    printf(&quot;%d&quot;, sc);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="main函数总控"><a href="#main函数总控" class="headerlink" title="main函数总控"></a>main函数总控</h3><p>贪吃蛇的原理，就是以某一实间间隔进行如上判断，然后进行屏幕扫描。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    page();//首页</span><br><span class="line">    ifspace();//回车开始 </span><br><span class="line">    system(&quot;cls&quot;);</span><br><span class="line">    randpos();//初始化蛇的位置 </span><br><span class="line">    //打印界面</span><br><span class="line">    while (1) &#123;</span><br><span class="line">        system(&quot;cls&quot;); </span><br><span class="line">        change();//改变方向</span><br><span class="line">        grow();//蛇变长</span><br><span class="line">     produce();//产生食物</span><br><span class="line">        move();</span><br><span class="line">        //判断蛇是否死亡</span><br><span class="line">        if (over() == 0) &#123;</span><br><span class="line">            printf(&quot;游戏结束！\n&quot;);</span><br><span class="line">            printf(&quot;最终分数: %d\n&quot;, sc);</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">        printsn();//在背景上显示蛇</span><br><span class="line">    printbg(); //打印背景</span><br><span class="line">       Score(); //打印分数</span><br><span class="line">        //Sleep(*sp); </span><br><span class="line">Sleep(150); //速度可调 (小丑) </span><br><span class="line">    &#125;</span><br><span class="line">    system(&quot;pause&quot;);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>我代码设计得还算简明易懂，未添加头文件；必要之处都给出了详细的注释，方便大家阅读。<br>非常希望诸位巨头能给出解决方案和宝贵建议！</p>]]></content>
      
      
      <categories>
          
          <category> 计算机编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 编程 </tag>
            
            <tag> C语言 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>游客须知</title>
      <link href="/2022/07/01/hello-world/"/>
      <url>/2022/07/01/hello-world/</url>
      
        <content type="html"><![CDATA[<h2 id="概况和注意事项"><a href="#概况和注意事项" class="headerlink" title="概况和注意事项"></a>概况和注意事项</h2><p>关于我个人的信息在<a href="https://xrhlongman.github.io/about/">关于笔者</a>这一页已经写过了，在此就不过多赘述。</p><h3 id="计算机编程方面"><a href="#计算机编程方面" class="headerlink" title="计算机编程方面"></a><a href="https://xrhlongman.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BC%96%E7%A8%8B/">计算机编程方面</a></h3><blockquote><p>首先大家请注意，我默认将代码页折叠，感觉这样会有更好的观感体验。一些图片可能会加载得比较慢，因为这个网站我没花一分钱(doge)。请大家谅解，将就一下吧(可怜捏)。<br>计算机方面我真的只是个爱好者，没什么语言基础，现在写出来的东西也不成文章，如果有大佬觉得有什么问题请不吝赐教。如果我运气好而且有能力的话可能可以进入<a href="http://www.cs.zju.edu.cn/">浙江大学计算机科学与技术学院</a>，这也是我一直以来的梦想，由此我就能从一个普通的爱好者变成一个普通的CS学生了捏。</p></blockquote><h3 id="大学生活"><a href="#大学生活" class="headerlink" title="大学生活"></a><a href="https://xrhlongman.github.io/categories/%E5%A4%A7%E5%AD%A6%E7%94%9F%E6%B4%BB/">大学生活</a></h3><p>毕竟是第一次上大学，从军训到选课，再到专业分流，新大一的一切一切都令人紧张而激动。这里就不得不提到我们的跑步打卡了。去过浙大紫金港的同胞们必然知道，紫金港有两个紧挨着的田径场；然而每到第十二节课结束，大约是晚上八点半，人潮就如黑云压城一般蜂拥向操场。没有五六个保安真的控制不住如此激动人心的场面。跑道上就像下饺子一样堆满了人。有的健步如飞，有的慢慢悠悠；既有校队在刻苦训练，也有我在拼命划水。这就是打卡制度催生下的浙大夜跑，在这里，每人每学期都要打卡48次，其中男生每次3K,女生每次2K。我算是一个跑步爱好者，领略了一回在人群中步履维艰，左支右绌的感觉。<br>在这个网站上，我会记录一些有趣的运动经历，希望引起同道中人的共鸣。</p><h3 id="最后说一句，请文明评论"><a href="#最后说一句，请文明评论" class="headerlink" title="最后说一句，请文明评论"></a>最后说一句，请文明评论</h3>]]></content>
      
      
      <categories>
          
          <category> 大学生活 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 编程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>半波分析的失误</title>
      <link href="/2020/04/09/%E5%8D%8A%E6%B3%A2%E5%B8%A6%E6%B3%95/"/>
      <url>/2020/04/09/%E5%8D%8A%E6%B3%A2%E5%B8%A6%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<blockquote><p>不要在意这个标题，我说不清出半波带误差的真正问题，还望巨佬在评论区加以说明。</p></blockquote><span id="more"></span><p>菲涅尔半波带法的次极大亮纹与标解夫琅禾费单缝振幅积分矢量法所解得的有那么一点微小的差异，有巨佬认为“在利用半波带法计算菲涅尔衍射的振幅时，通常不考虑半波带内的面元到场点之间光程不同引起的相位变化”，只能做一些初步研究。<br><img src="https://s2.loli.net/2022/07/03/7PQcbJkGW5REZjS.jpg"></p><h2 id="运算"><a href="#运算" class="headerlink" title="运算"></a>运算</h2><p>模仿振幅矢量法，令sinψ&#x3D;(2k+e)λ&#x2F;2,e∈(0,2),k∈N+,则Δφ&#x3D;(2k+e)π,矢量首尾相接构成k层圆和圆弧AB.其对应圆心角eπ.构成k层圆的小矢量的合矢量为零,构成圆弧AB的合矢量大小AB决定了场点P的振幅.↓<br><img src="https://s2.loli.net/2022/07/03/xebSGiyTVP5l6LE.png"><br>R&#x3D;A⌒B&#x2F;eπ,总强长为A,其所对应圆心角为(2k+e)π.等比关系有A⌒B&#x2F;eπ&#x3D;A。&#x2F;(2k+e)π.初中几何可得，P点矢量的振幅表示几何意义为线段AB,即</p><center>A=2Rsin(eπ/2)=2A⌒Bsin(eπ/2)/eπ=A。sin(eπ/2)/(kπ+eπ/2)①</center>两边求导:<center>dA/de=A。cos(eπ/2)/(2k+e)-2A。sin(eπ/2)/(2k+e)²②</center>若求极值(次极大),则:<center>tan(eπ/2)=kπ+eπ/2③</center>图解超越方程<p><img src="https://s2.loli.net/2022/07/03/OabSxF6VNWkjEKs.png"></p><table><thead><tr><th align="center">k的值</th><th align="center">e的值</th></tr></thead><tbody><tr><td align="center">1</td><td align="center">0.861</td></tr><tr><td align="center">2</td><td align="center">0.918</td></tr><tr><td align="center">3</td><td align="center">0.942</td></tr><tr><td align="center">4</td><td align="center">0.956</td></tr><tr><td align="center">…</td><td align="center">…</td></tr></tbody></table><p>表格可见k的值越大，误差越小</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>决定单缝衍射明纹振幅的不足一个半波带,半波带法却在“相消”上显得无懈可击,最终被证明是近似的.<br>最令人崩溃的是，我只能理解用上述偏振法的变形做出来的答案是对的:我们假设两种情况，第一种相位余数是准半波，半径R₁，第二种比半波小一点，半径R₂.在A。一定时，虽然Δφ₁＞Δφ₂，但由分比得，定有R₁＜R₂，而A&#x3D;RΔφ，因此其实两者的大小是不一定的.</p>]]></content>
      
      
      <categories>
          
          <category> 物理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 物理 </tag>
            
            <tag> 竞赛 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
